module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBoard {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Board {
  id: ID!
  team: Team!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type BoardConnection {
  pageInfo: PageInfo!
  edges: [BoardEdge]!
  aggregate: AggregateBoard!
}

input BoardCreateInput {
  id: ID
  team: TeamCreateOneWithoutBoardsInput!
  items: ItemCreateManyWithoutBoardInput
}

input BoardCreateManyWithoutTeamInput {
  create: [BoardCreateWithoutTeamInput!]
  connect: [BoardWhereUniqueInput!]
}

input BoardCreateOneWithoutItemsInput {
  create: BoardCreateWithoutItemsInput
  connect: BoardWhereUniqueInput
}

input BoardCreateWithoutItemsInput {
  id: ID
  team: TeamCreateOneWithoutBoardsInput!
}

input BoardCreateWithoutTeamInput {
  id: ID
  items: ItemCreateManyWithoutBoardInput
}

type BoardEdge {
  node: Board!
  cursor: String!
}

enum BoardOrderByInput {
  id_ASC
  id_DESC
}

type BoardPreviousValues {
  id: ID!
}

input BoardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [BoardScalarWhereInput!]
  OR: [BoardScalarWhereInput!]
  NOT: [BoardScalarWhereInput!]
}

type BoardSubscriptionPayload {
  mutation: MutationType!
  node: Board
  updatedFields: [String!]
  previousValues: BoardPreviousValues
}

input BoardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BoardWhereInput
  AND: [BoardSubscriptionWhereInput!]
  OR: [BoardSubscriptionWhereInput!]
  NOT: [BoardSubscriptionWhereInput!]
}

input BoardUpdateInput {
  team: TeamUpdateOneRequiredWithoutBoardsInput
  items: ItemUpdateManyWithoutBoardInput
}

input BoardUpdateManyWithoutTeamInput {
  create: [BoardCreateWithoutTeamInput!]
  delete: [BoardWhereUniqueInput!]
  connect: [BoardWhereUniqueInput!]
  set: [BoardWhereUniqueInput!]
  disconnect: [BoardWhereUniqueInput!]
  update: [BoardUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [BoardUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [BoardScalarWhereInput!]
}

input BoardUpdateOneRequiredWithoutItemsInput {
  create: BoardCreateWithoutItemsInput
  update: BoardUpdateWithoutItemsDataInput
  upsert: BoardUpsertWithoutItemsInput
  connect: BoardWhereUniqueInput
}

input BoardUpdateWithoutItemsDataInput {
  team: TeamUpdateOneRequiredWithoutBoardsInput
}

input BoardUpdateWithoutTeamDataInput {
  items: ItemUpdateManyWithoutBoardInput
}

input BoardUpdateWithWhereUniqueWithoutTeamInput {
  where: BoardWhereUniqueInput!
  data: BoardUpdateWithoutTeamDataInput!
}

input BoardUpsertWithoutItemsInput {
  update: BoardUpdateWithoutItemsDataInput!
  create: BoardCreateWithoutItemsInput!
}

input BoardUpsertWithWhereUniqueWithoutTeamInput {
  where: BoardWhereUniqueInput!
  update: BoardUpdateWithoutTeamDataInput!
  create: BoardCreateWithoutTeamInput!
}

input BoardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  team: TeamWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  AND: [BoardWhereInput!]
  OR: [BoardWhereInput!]
  NOT: [BoardWhereInput!]
}

input BoardWhereUniqueInput {
  id: ID
}

enum category {
  START
  STOP
  CONTINUE
  ACTION
}

type Item {
  id: ID!
  board: Board!
  text: String!
  category: category!
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  board: BoardCreateOneWithoutItemsInput!
  text: String!
  category: category!
}

input ItemCreateManyWithoutBoardInput {
  create: [ItemCreateWithoutBoardInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateWithoutBoardInput {
  id: ID
  text: String!
  category: category!
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  category_ASC
  category_DESC
}

type ItemPreviousValues {
  id: ID!
  text: String!
  category: category!
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  category: category
  category_not: category
  category_in: [category!]
  category_not_in: [category!]
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  board: BoardUpdateOneRequiredWithoutItemsInput
  text: String
  category: category
}

input ItemUpdateManyDataInput {
  text: String
  category: category
}

input ItemUpdateManyMutationInput {
  text: String
  category: category
}

input ItemUpdateManyWithoutBoardInput {
  create: [ItemCreateWithoutBoardInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutBoardInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutBoardInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithoutBoardDataInput {
  text: String
  category: category
}

input ItemUpdateWithWhereUniqueWithoutBoardInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutBoardDataInput!
}

input ItemUpsertWithWhereUniqueWithoutBoardInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutBoardDataInput!
  create: ItemCreateWithoutBoardInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  board: BoardWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  category: category
  category_not: category
  category_in: [category!]
  category_not_in: [category!]
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBoard(data: BoardCreateInput!): Board!
  updateBoard(data: BoardUpdateInput!, where: BoardWhereUniqueInput!): Board
  upsertBoard(where: BoardWhereUniqueInput!, create: BoardCreateInput!, update: BoardUpdateInput!): Board!
  deleteBoard(where: BoardWhereUniqueInput!): Board
  deleteManyBoards(where: BoardWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  board(where: BoardWhereUniqueInput!): Board
  boards(where: BoardWhereInput, orderBy: BoardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Board]!
  boardsConnection(where: BoardWhereInput, orderBy: BoardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BoardConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  node(id: ID!): Node
}

type Subscription {
  board(where: BoardSubscriptionWhereInput): BoardSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
}

type Team {
  id: ID!
  name: String!
  boards(where: BoardWhereInput, orderBy: BoardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Board!]
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  id: ID
  name: String!
  boards: BoardCreateManyWithoutTeamInput
}

input TeamCreateOneWithoutBoardsInput {
  create: TeamCreateWithoutBoardsInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutBoardsInput {
  id: ID
  name: String!
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type TeamPreviousValues {
  id: ID!
  name: String!
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateInput {
  name: String
  boards: BoardUpdateManyWithoutTeamInput
}

input TeamUpdateManyMutationInput {
  name: String
}

input TeamUpdateOneRequiredWithoutBoardsInput {
  create: TeamCreateWithoutBoardsInput
  update: TeamUpdateWithoutBoardsDataInput
  upsert: TeamUpsertWithoutBoardsInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutBoardsDataInput {
  name: String
}

input TeamUpsertWithoutBoardsInput {
  update: TeamUpdateWithoutBoardsDataInput!
  create: TeamCreateWithoutBoardsInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  boards_every: BoardWhereInput
  boards_some: BoardWhereInput
  boards_none: BoardWhereInput
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
}
`
      }
    